// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel DynamicLight
#pragma kernel BlurAndApplyShadow

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct MeshTriangle
{
	float3 p1WPos;
	float2 p1Uv;
	float3 p2WPos;
	float2 p2Uv;
	float3 p3WPos;
	float2 p3Uv;
	float3 normal;
	float3 tangent;
	float3 binormal;
};

struct CSLight
{
	float3 loc;
	float4 color;
	float range;
	float intensity;
};

struct usedUV
{
	float2 uvPos;
	float3 worldLoc;
	float3 normal;
	int used;
	float lit;
};

StructuredBuffer<MeshTriangle> triangles;
StructuredBuffer<CSLight> lights;
RWStructuredBuffer<usedUV> usedUVs;

RWTexture2D<float4> Result; //finalResult

RWTexture2D<float4> RlTLight; //real time light
//RWTexture2D<float4> BLight; //baked light
//RWTexture2D<float4> shad;
RWTexture2D<float4> nm;

int numLights;
int numTriangles;
int texRes;
static float eps = 0.046;

/*float hash11(float p)
{
	p = frac(p * 0.1031);
	p *= p + 33.33;
	p *= p + p;
	p = frac(p);
	//p -= 0.5;
	return p;
}*/

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	//Result[id.xy] = float4(0.01, 0.01, 0., 1); //ambient light
	float a;
	float b;
	float c;
	float2 curUV = float2((float)id.x / (float)texRes, (float)id.y / (float)texRes);
	for (int i = 0; i < numTriangles; i++)
	{
		float2 p1 = triangles[i].p1Uv;
		float2 p2 = triangles[i].p2Uv;
		float2 p3 = triangles[i].p3Uv;

		a = ((p2.y - p3.y) * (curUV.x - p3.x) + (p3.x - p2.x) * (curUV.y - p3.y)) / ((p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y));
		b = ((p3.y - p1.y) * (curUV.x - p3.x) + (p1.x - p3.x) * (curUV.y - p3.y)) / ((p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y));
		c = 1 - a - b;
		if (0 - eps <= a && a <= 1 + eps && 0 - eps <= b && b <= 1 + eps && 0 - eps <= c && c <= 1 + eps)
		{
			usedUVs[texRes * id.y + id.x].used = 1;
			usedUVs[texRes * id.y + id.x].uvPos = id.xy;

			float3 wp1 = triangles[i].p1WPos;
			float3 wp2 = triangles[i].p2WPos;
			float3 wp3 = triangles[i].p3WPos;

			usedUVs[texRes * id.y + id.x].worldLoc = a * wp1 + b * wp2 + c * wp3;
			nm[id.xy].g = 1 - nm[id.xy].g;
			nm[id.xy] = nm[id.xy] *  2 - 1;
			usedUVs[texRes * id.y + id.x].normal = triangles[i].normal * nm[id.xy].b + triangles[i].binormal * nm[id.xy].g + triangles[i].tangent* nm[id.xy].r;// 
			usedUVs[texRes * id.y + id.x].normal = normalize(usedUVs[texRes * id.y + id.x].normal);
			break;
		}
	}
}

[numthreads(8,8,1)]
void DynamicLight(uint3 id : SV_DispatchThreadID)
{
	float4 amb = float4(0.3/2, 0.15/2, 0.15/2, 1);
    RlTLight[id.xy] = amb; //ambient light
    //shad[id.xy] = 1;
	float4 totalCol = 0;
    float4 shadowVal = 0;
	usedUVs[texRes * id.y + id.x].lit = 1;
	if (usedUVs[texRes * id.y + id.x].used == 1)
	{
		for (int i = 0; i < numLights; i++)
		{
			float3 lightLoc = lights[i].loc;
            float3 locMinusLight = usedUVs[texRes * id.y + id.x].worldLoc - lightLoc;
            float3 uvWPos = usedUVs[texRes * id.y + id.x].worldLoc;
            float dist = length(locMinusLight);
			float maxDist = lights[i].range;
			float4 lightCol = normalize(lights[i].color) * lights[i].intensity;
            float3 lightVec = normalize(locMinusLight);
			float angleBetweenLightAndLoc = dot(lightVec, usedUVs[texRes * id.y + id.x].normal);
            if (dist < maxDist && angleBetweenLightAndLoc < 0)
            {
                bool shadowHit = false;
                float lightHide = 1;
                float distFromInterToUV = 0;
                float distFromLightToPlane = 0;
                for (int j = 0; j < numTriangles; j++)
                {
                    //float3 colliderProjection = triangles[i].p1WPos - uvWPos;

                    float parallelDot = dot(lightVec, triangles[j].normal); //see if plane and lightVec are near parrallel

                    if (abs(parallelDot) >= -eps) // if they are not, then they intersect (consider adding epsilon)
                    {
                        distFromLightToPlane = dot((triangles[j].p1WPos - lightLoc), triangles[j].normal) / parallelDot; //find if they intersect behind the ray origin (whatever that means?)
                        if (distFromLightToPlane >= dist - eps)
                        {
                            continue;
                        }
                        if (distFromLightToPlane >= -eps /*&& distFromLightToPlane < dist*/)
                        {
                            float3 inters = lightLoc + (distFromLightToPlane * lightVec);

                            float3 p1 = triangles[j].p1WPos;
                            float3 p2 = triangles[j].p2WPos;
                            float3 p3 = triangles[j].p3WPos;

                            float3 v0 = p2 - p1;
                            float3 v1 = p3 - p1;
                            float3 v2 = inters - p1;

                            float d00 = dot(v0, v0);
                            float d01 = dot(v0, v1);
                            float d11 = dot(v1, v1);
                            float d20 = dot(v2, v0);
                            float d21 = dot(v2, v1);

                            float denom = d00 * d11 - d01 * d01;

                            float a = (d11 * d20 - d01 * d21) / denom;
                            float b = (d00 * d21 - d01 * d20) / denom;
                            float c = 1.0f - a - b;

                            if (0 - eps <= a && a <= 1 + eps && 0 - eps <= b && b <= 1 + eps && 0 - eps <= c && c <= 1 + eps)
                            {
                                float newDist = length(inters - uvWPos);
                                distFromInterToUV = max(newDist, distFromInterToUV);
                                shadowHit = true;
                            }
                        }
                    }
                }
                //if(shadowHit)
                //{
                //    //lightHide = (distFromInterToUV / dist);
                //    //lightHide *= lightHide * lightHide;
                //    //float4 val = (1 - dist / maxDist) * -1 * angleBetweenLightAndLoc * lightHide;
                //    //totalCol = lerp(totalCol, lightCol, val * val * usedUVs[texRes * id.y + id.x].lit);

                //    break;
                //}
                if(!shadowHit)
                {
                    float4 val = (1 - dist / maxDist) * -1 * angleBetweenLightAndLoc;
                    totalCol = lerp(totalCol, lightCol, val * val * usedUVs[texRes * id.y + id.x].lit);
                }
            }
        }
        RlTLight[id.xy] += totalCol;
        //shad[id.xy] = shadowVal;
    }
}


static int kSize = 2;//should be made independent based on texture size

[numthreads(8, 8, 1)]
void BlurAndApplyShadow(uint3 id : SV_DispatchThreadID)
{
 
    //if (shad[id.xy].r < 0.5)
    //{
    //    float4 result = shad[id.xy].y;
    
    //    for (int x = -kSize; x <= kSize; x++)
    //    {
    //        for (int y = -kSize; y <= kSize; y++)
    //        {
    //            result += shad[id.xy + int2(x, y)] / float(pow(2 * kSize, 2));
    //        }
    //    }
    //    shad[id.xy] += result;
    //}
    float4 col = RlTLight[id.xy]; // * (shad[id.xy].x);
    Result[id.xy] = col;
}

/*
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel DynamicLight

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

struct MeshTriangle
{
	float3 p1WPos;
	float2 p1Uv;
	float3 p2WPos;
	float2 p2Uv;
	float3 p3WPos;
	float2 p3Uv;
	float3 normal;
	float3 tangent;
	float3 binormal;
};

struct CSLight
{
	float3 loc;
	float4 color;
	float range;
	float intensity;
};

struct usedUV
{
	float2 uvPos;
	float3 worldLoc;
	float3 normal;
	int used;
	float lit;
};

StructuredBuffer<MeshTriangle> triangles;
StructuredBuffer<CSLight> lights;
RWStructuredBuffer<usedUV> usedUVs;

int numLights;
int numTriangles;
int texRes;
static float eps = 0.046;
RWTexture2D<float4> nm;

/*float hash11(float p)
{
	p = frac(p * 0.1031);
	p *= p + 33.33;
	p *= p + p;
	p = frac(p);
	//p -= 0.5;
	return p;
}

/*
[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	//Result[id.xy] = float4(0.01, 0.01, 0., 1); //ambient light
    float a;
    float b;
    float c;
    float2 curUV = float2((float) id.x / (float) texRes, (float) id.y / (float) texRes);
    for (int i = 0; i < numTriangles; i++)
    {
        float2 p1 = triangles[i].p1Uv;
        float2 p2 = triangles[i].p2Uv;
        float2 p3 = triangles[i].p3Uv;

        a = ((p2.y - p3.y) * (curUV.x - p3.x) + (p3.x - p2.x) * (curUV.y - p3.y)) / ((p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y));
        b = ((p3.y - p1.y) * (curUV.x - p3.x) + (p1.x - p3.x) * (curUV.y - p3.y)) / ((p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y));
        c = 1 - a - b;
        if (0 - eps <= a && a <= 1 + eps && 0 - eps <= b && b <= 1 + eps && 0 - eps <= c && c <= 1 + eps)
        {
            usedUVs[texRes * id.y + id.x].used = 1;
            usedUVs[texRes * id.y + id.x].uvPos = id.xy;

            float3 wp1 = triangles[i].p1WPos;
            float3 wp2 = triangles[i].p2WPos;
            float3 wp3 = triangles[i].p3WPos;

            usedUVs[texRes * id.y + id.x].worldLoc = a * wp1 + b * wp2 + c * wp3;
            nm[id.xy].g = 1 - nm[id.xy].g;
            nm[id.xy] = nm[id.xy] * 2 - 1;
            usedUVs[texRes * id.y + id.x].normal = triangles[i].normal * nm[id.xy].b + triangles[i].binormal * nm[id.xy].g + triangles[i].tangent * nm[id.xy].r; // 
            usedUVs[texRes * id.y + id.x].normal = normalize(usedUVs[texRes * id.y + id.x].normal);
            break;
        }
    }
}

[numthreads(8, 8, 1)]
void DynamicLight(uint3 id : SV_DispatchThreadID)
{
    float4 amb = float4(0.3 / 2, 0.15 / 2, 0.15 / 2, 1);
    Result[id.xy] = amb; //ambient light
    float4 lightCol = 0;
    usedUVs[texRes * id.y + id.x].lit = 1;
    if (usedUVs[texRes * id.y + id.x].used == 1)
    {
        for (int i = 0; i < numLights; i++)
        {
            float3 lightLoc = lights[i].loc;
            float3 lightMinusLoc = lightLoc - usedUVs[texRes * id.y + id.x].worldLoc;
            float dist = length(lightMinusLoc);
            float maxDist = lights[i].range;
            float4 col = normalize(lights[i].color) * lights[i].intensity;
            float3 lightVec = normalize(lightMinusLoc);
            float angleBetweenLightAndLoc = dot(lightVec, usedUVs[texRes * id.y + id.x].normal);

            if (dist < maxDist && angleBetweenLightAndLoc > 0)
            {
				//lightCol = col *angleBetweenLightAndLoc;
                float4 val = (1 - dist / maxDist) * -1 * angleBetweenLightAndLoc;
                lightCol = lerp(lightCol, col, val * val * usedUVs[texRes * id.y + id.x].lit);
            }
        }
        Result[id.xy] += lightCol;
    }
}

[numthreads(8, 8, 1)]
void rayTracedLight(uint3 id : SV_DispatchThreadID)
{

}
*/
