// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel uvToWorld
#pragma kernel DynamicLight
#pragma kernel Blur
#pragma kernel Apply
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct MeshTriangle
{
	float3 p1WPos;
	float2 p1Uv;
	float3 p2WPos;
	float2 p2Uv;
	float3 p3WPos;
	float2 p3Uv;
	float3 normal;
	float3 tangent;
	float3 binormal;
};

struct CSLight
{
    int castShadow;
	float3 loc;
	float4 color;
	float range;
	float intensity;
};

struct usedUV
{
    float distFromShadowedObject;
	float distFromLight;
	float3 worldLoc;
	float3 normal;
	float3 geoNormal;
	int used;
	float lit;
};

StructuredBuffer<MeshTriangle> triangles;
StructuredBuffer<CSLight> lights;
RWStructuredBuffer<usedUV> usedUVs;
StructuredBuffer<int> numLights;


RWTexture2D<float4> totalResult; //finalResult of a dispatch (can be the actual final result, or real time lighting, or baked lighting depending on usage) 

RWTexture2D<float4> RlTLight; //real time light texture used for combingin in final apply
RWTexture2D<float4> BLight; //baked light texture used for combining in final apply
RWTexture2D<float4> shad; //the areas that get shaded(from geometry)
RWTexture2D<float4> unlit; //areas that dont get lit
RWTexture2D<float4> nm; //normal map

//int numLights;
int numTriangles;
int texRes;
static float eps = 0.046;

float hash11(float p)
{
    p = frac(p * 0.1031);
    p *= p + 33.33;
    p *= p + p;
    p = frac(p);
    //p -= 0.5;
    return p;
}

[numthreads(8,8,1)]
void uvToWorld (uint3 id : SV_DispatchThreadID)
{
	//Result[id.xy] = float4(0.01, 0.01, 0., 1); //ambient light
	float a;
	float b;
	float c;
	float2 curUV = float2((float)id.x / (float)texRes, (float)id.y / (float)texRes);
    //could be cool to check only half the triangles, and then randomly use pick them.
	for (int i = 0; i < numTriangles; i++)
	{
		float2 p1 = triangles[i].p1Uv;
		float2 p2 = triangles[i].p2Uv;
		float2 p3 = triangles[i].p3Uv;


		a = ((p2.y - p3.y) * (curUV.x - p3.x) + (p3.x - p2.x) * (curUV.y - p3.y)) / ((p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y));
		b = ((p3.y - p1.y) * (curUV.x - p3.x) + (p1.x - p3.x) * (curUV.y - p3.y)) / ((p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y));
		c = 1 - a - b;
        
        if (0 - eps <= a && a <= 1 + eps && 0 - eps <= b && b <= 1 + eps && 0 - eps <= c && c <= 1 + eps) //inside triangle
		{
			usedUVs[texRes * id.y + id.x].used = 1;
			//usedUVs[texRes * id.y + id.x].uvPos = id.xy;//what is its purpose? 

			float3 wp1 = triangles[i].p1WPos;
			float3 wp2 = triangles[i].p2WPos;
			float3 wp3 = triangles[i].p3WPos;

			usedUVs[texRes * id.y + id.x].worldLoc = a * wp1 + b * wp2 + c * wp3;
			nm[id.xy].g = 1 - nm[id.xy].g;
			nm[id.xy] = nm[id.xy] *  2 - 1;
			usedUVs[texRes * id.y + id.x].normal = triangles[i].normal * nm[id.xy].b + triangles[i].binormal * nm[id.xy].g + triangles[i].tangent* nm[id.xy].r;// 
			usedUVs[texRes * id.y + id.x].normal = normalize(usedUVs[texRes * id.y + id.x].normal);
            usedUVs[texRes * id.y + id.x].geoNormal = triangles[i].normal;
			break;
		}
	}
}

[numthreads(8,8,1)]
void DynamicLight(uint3 id : SV_DispatchThreadID)
{
    float4 amb = 0; //float4(0.3/2, 0.15/2, 0.15/2, 1);
    //totalResult[id.xy] = amb; //ambient light
    float4 threadUnlit = 0;
    float4 threadShad = 0;
    int uvInd = texRes * id.y + id.x;
    usedUVs[uvInd].lit = 1;
    if (usedUVs[uvInd].used == 1)
    {
        for (int i = 0; i < numLights[0]; i++)
        {
            float3 lightLoc = lights[i].loc;
            float3 locMinusLight = usedUVs[uvInd].worldLoc - lightLoc;
            float3 uvWPos = usedUVs[texRes * id.y + id.x].worldLoc;
            float dist = length(locMinusLight);
            float maxDist = lights[i].range;
            float3 lightVec = normalize(locMinusLight);
            float angleBetweenLightAndLocWNormalMap = dot(lightVec, usedUVs[uvInd].normal);
            float angleBetweenLightAndLocGeo = dot(lightVec, usedUVs[uvInd].geoNormal);
            if (dist < maxDist && angleBetweenLightAndLocGeo < 0)
            {
                if (lights[i].castShadow == 0)
                {
                    if (angleBetweenLightAndLocWNormalMap < 0)
                    {
                        float4 val = (1 - dist / maxDist) * -1 * angleBetweenLightAndLocWNormalMap;
                        threadUnlit = 1 - (val * val * usedUVs[uvInd].lit);
                        continue;
                    }
                    else
                    {
                        threadUnlit = 1;
                        continue;
                    }
                }
                bool shadowHit = false;
                threadUnlit = 0;
                threadShad = 0;
                float distFromLightToPlane = 0;
 
                for (int j = 0; j < numTriangles; j++)
                {
                    float parallelDot = dot(lightVec, triangles[j].normal); //see if plane and lightVec are near parrallel

                    if (abs(parallelDot) >= 0) // if they are not, then they intersect
                    {
                        distFromLightToPlane = dot(triangles[j].p3WPos - lightLoc, triangles[j].normal) / parallelDot;
                        
                        if (distFromLightToPlane >= dist - eps)
                            continue;
                        if (distFromLightToPlane - eps >= 0 /*&& distFromLightToPlane < dist*/)
                        {
                            usedUVs[uvInd].distFromLight = length(usedUVs[uvInd].worldLoc - lightLoc);

                            float3 inters = lightLoc + (distFromLightToPlane * lightVec);

                            float3 p1 = triangles[j].p1WPos;
                            float3 p2 = triangles[j].p2WPos;
                            float3 p3 = triangles[j].p3WPos;

                            float3 v0 = p2 - p1;
                            float3 v1 = p3 - p1;
                            float3 v2 = inters - p1;

                            float d00 = dot(v0, v0);
                            float d01 = dot(v0, v1); //dot is shorthand for v0.x * v1.x + v0.y * v1.y + v0.z * v1.z
                            float d11 = dot(v1, v1);
                            float d20 = dot(v2, v0);
                            float d21 = dot(v2, v1);

                            float denom = d00 * d11 - d01 * d01;

                            float a = (d11 * d20 - d01 * d21) / denom;
                            float b = (d00 * d21 - d01 * d20) / denom;
                            float c = 1.0f - a - b;

                            if (0 - eps <= a && a <= 1 + eps && 0 - eps <= b && b <= 1 + eps && 0 - eps <= c && c <= 1 + eps)
                            {
                                float distFromInterToUV = length(inters - uvWPos);

                                if (usedUVs[uvInd].distFromShadowedObject != 0)
                                    usedUVs[uvInd].distFromShadowedObject = min(distFromInterToUV, usedUVs[uvInd].distFromShadowedObject);
                                else
                                    usedUVs[uvInd].distFromShadowedObject = distFromInterToUV;
                               
                                shadowHit = true;
                                threadShad = 1;

                            }
                        }
                    }
                }
                if (!shadowHit)
                    usedUVs[uvInd].distFromShadowedObject = 0; //no object for shadow
                if (angleBetweenLightAndLocWNormalMap < 0)
                {
                    float4 val = (1 - dist / maxDist) * -1 * angleBetweenLightAndLocWNormalMap;
                    threadUnlit = 1 - (val * val * usedUVs[uvInd].lit);
                }
                else
                    threadUnlit = 1;
            }
            else
            {
                threadUnlit = 1;
                threadShad = 1;
            }
            unlit[id.xy] += threadUnlit;
            unlit[id.xy] = clamp(unlit[id.xy], 0, 1);
            shad[id.xy] += threadShad;
            shad[id.xy] = clamp(shad[id.xy], 0, 1);
        }
    }
}

[numthreads(8, 8, 1)]
void Blur(uint3 id : SV_DispatchThreadID)
{
   //to do:
   //make baked work
    int uvInd = texRes * id.y + id.x;
    
    //float blurAmount = (usedUVs[uvInd].distFromShadowedObject / usedUVs[uvInd].distFromLight);
    //blurAmount = pow(blurAmount, 4);
    ////totalResult[id.xy] += blurAmount;
    //blurAmount *= 60;
    ////blurAmount = 4;
    //float4 sum = shad[id.xy];
    //float addVal = 0.025;
    //for (int i = 0; i < blurAmount; i++)
    //{
    //    if (sum.r < 1.0 - addVal)
    //        sum += addVal;
    //}
    //shad[id.xy] = sum;
    
    //float4 lightCol = lights[0].color * lights[0].intensity;

    float4 unlitAndShad = unlit[id.xy] * shad[id.xy];
    //unlitAndShad = 1 - unlitAndShad;
    totalResult[id.xy] = unlit[id.xy]; // * lightCol; //shad[id.xy];
    shad[id.xy] = float4(0, 0, 0, 0);
    unlit[id.xy] = float4(0, 0, 0, 0);
}

[numthreads(8, 8, 1)]
void Apply(uint3 id : SV_DispatchThreadID)
{
    float4 totCol = RlTLight[id.xy] + BLight[id.xy];
    totCol = saturate(totCol);
    totalResult[id.xy] = totCol;//lerp(RlTLight[id.xy], BLight[id.xy], 0.5);
    
   
    //totalResult[id.xy] = float4(1, 0, 0, 1);

    //float4 col = [id.xy]; // * (shad[id.xy].x);
    //totalResult[id.xy] = col;
}
